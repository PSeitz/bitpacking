#!/usr/bin/env python
import sys
def howmany(bit):
    """ how many values are we going to pack? """
    return 256

def howmanywords(bit):
    return (howmany(bit) * bit + 255)/256

def howmanybytes(bit):
    return howmanywords(bit) * 16

print("""
/** code generated by avxpacking.py starts here **/
""")

def plurial(number):
    if(number <> 1):
        return "s"
    else :
        return ""

for bit in range(1,33):
    print("")
    print("/* we are going to pack {0} {1}-bit values, touching {2} 256-bit words, using {3} bytes */ ".format(howmany(bit),bit,howmanywords(bit),howmanybytes(bit)))
    print("unsafe fn avxpackblock{0}(input_ptr: *const __m256i, compressed: *mut __m256i) {{".format(bit))
    print("  /* we are going to touch  {0} 256-bit word{1} */ ".format(howmanywords(bit),plurial(howmanywords(bit))));
    print("  let mut w0: __m256i;")
    if howmanywords(bit) > 1:
        print("  let mut w1: __m256i;")
    if (bit & (bit-1)) != 0:
        print("// not a power of two.")
        print("let mut tmp: __m256i; /* used to store inputs at word boundary */")
    oldword = 0
    for j in range(howmany(bit)/8):
      firstword = j * bit / 32
      if(firstword > oldword):
        print("  _mm256_storeu_si256(compressed.offset({0} as isize), w{1});".format(oldword,oldword%2))
        oldword = firstword
      secondword = (j * bit + bit - 1)/32
      firstshift = (j*bit) % 32
      if( firstword == secondword):
          if(firstshift == 0):
            print("  w{0} = _mm256_lddqu_si256 (input_ptr.offset({1}));".format(firstword%2,j))
          else:
            print("  w{0} = _mm256_or_si256(w{0},_mm256_slli_epi32(_mm256_lddqu_si256(input_ptr.offset({1})) , {2}));".format(firstword%2,j,firstshift))
      else:
          print("  tmp = _mm256_lddqu_si256 (input_ptr.offset({0}));".format(j))
          print("  w{0} = _mm256_or_si256(w{0},_mm256_slli_epi32(tmp , {2}));".format(firstword%2,j,firstshift))
          secondshift = 32-firstshift
          print("  w{0} = _mm256_srli_epi32(tmp,{2});".format(secondword%2,j,secondshift))
    print("  _mm256_storeu_si256(compressed.offset({0}), w{1});".format(secondword,secondword%2))
    print("}");
    print("")


for bit in range(1,33):
    print("")
    print("/* we packed {0} {1}-bit values, touching {2} 256-bit words, using {3} bytes */ ".format(howmany(bit),bit,howmanywords(bit),howmanybytes(bit)))
    print("unsafe fn avxunpackblock{0}(compressed: *const __m256i, out: *mut __m256i) {{".format(bit));
    print("  /* we are going to access  {0} 256-bit word{1} */ ".format(howmanywords(bit),plurial(howmanywords(bit))));
    print("let mut w0: __m256i;")
    if(howmanywords(bit) != 1):
      print("let mut w1: __m256i;")
    if(bit < 32): print("  let mask: __m256i = _mm256_set1_epi32({0});".format((1<<bit)-1));
    maskstr = " _mm256_and_si256( mask, {0}) "
    if (bit == 32) : maskstr = " {0} " # no need
    oldword = 0
    print("  w0 = _mm256_lddqu_si256(compressed);")
    for j in range(howmany(bit)/8):
      firstword = j * bit / 32
      secondword = (j * bit + bit - 1)/32
      if(secondword > oldword):
        print("  w{0} = _mm256_lddqu_si256(compressed.offset({1}));".format(secondword%2,secondword))
        oldword = secondword
      firstshift = (j*bit) % 32
      firstshiftstr = "_mm256_srli_epi32(w{0}, " + str(firstshift)+") "
      if(firstshift == 0):
          firstshiftstr =" w{0} " # no need
      wfirst = firstshiftstr.format(firstword%2)
      if( firstword == secondword):
          if(firstshift + bit <> 32):
            wfirst  = maskstr.format(wfirst)
          print("  _mm256_storeu_si256(out.offset({0}), {1});".format(j,wfirst))
      else:
          secondshift = (32-firstshift)
          wsecond = "_mm256_slli_epi32(w{0}, {1}) ".format((firstword+1)%2,secondshift)
          wfirstorsecond = " _mm256_or_si256({0},{1}) ".format(wfirst,wsecond)
          wfirstorsecond = maskstr.format(wfirstorsecond)
          print("  _mm256_storeu_si256(out.offset({0}),    {1});".format(j,wfirstorsecond))
    print("}");
    print("")


print("""
unsafe fn avxunpackblock(compressed: *const __m256i, out: *mut __m256i, num_bits: u8) {
    match num_bits {""");
for i in range(0, 33):
    print("\t\t%i => avxunpackblock%i(compressed, out)," % (i, i))
print("""\t\t_ => panic!("num_bits must be between [0..num_bits].")""")
print("\t}")
print("}")



print("""
unsafe fn avxpackblock(input_ptr: *const __m256i, compressed: *mut __m256i, num_bits: u8) { 
    match num_bits {""");
for i in range(0, 33):
    print("\t\t%i => avxpackblock%i(input_ptr, compressed)," % (i, i))
print("""\t\t_ => panic!("num_bits must be between [0..num_bits].")""")
print("\t}")
print("}")
